<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><title>Search and replace tricks with ripgrep</title><link href=https://learnbyexample.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><script src=https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js></script><link href=https://learnbyexample.github.io/site.css rel=stylesheet><meta content="Search and replace tricks with ripgrep" property=og:title><meta content=website property=og:type><meta content="Examples for single and multiline search and replace with ripgrep, serves as a handy alternative for sed in some cases" property=og:description><meta content=https://learnbyexample.github.io/substitution-with-ripgrep/ property=og:url><meta content=@learn_byexample property=twitter:site><link href=https://learnbyexample.github.io/favicon.svg rel=icon><link rel="shortcut icon" href=https://learnbyexample.github.io/favicon.png><body><div class=container><div class=mobile-navbar id=mobile-navbar><div class=mobile-header-logo><a class=logo href=/>learnbyexample</a></div><div class="mobile-navbar-icon icon-out"><span></span><span></span><span></span></div></div><nav class="mobile-menu slideout-menu slideout-menu-left" id=mobile-menu><ul class=mobile-menu-list><li class=mobile-menu-item><a href=https://learnbyexample.github.io/books> Books </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/mini> Mini </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/tips> Tips </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/tags> Tags </a><li class=mobile-menu-item><a href=https://learnbyexample.github.io/about> About </a></ul></nav><header id=header><div class=logo><a href=https://learnbyexample.github.io>learnbyexample</a></div><nav class=menu><ul><li><a href=https://learnbyexample.github.io/books> Books </a><li><a href=https://learnbyexample.github.io/mini> Mini </a><li><a href=https://learnbyexample.github.io/tips> Tips </a><li><a href=https://learnbyexample.github.io/tags> Tags </a><li><a href=https://learnbyexample.github.io/about> About </a></ul></nav></header><main><div class=content id=mobile-panel><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#global-search-and-replace>Global search and replace</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#matching-nth-occurrence>Matching Nth occurrence</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#in-place-workaround>In-place workaround</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#rust-regex-and-pcre2>Rust regex and PCRE2</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#extract-and-modify>Extract and modify</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#fixed-string-matching>Fixed string matching</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#multiline-matching>Multiline matching</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#handling-dos-style-input>Handling dos-style input</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#speed-comparison-with-gnu-sed>Speed comparison with GNU sed</a><li><a class=toc-link href=https://learnbyexample.github.io/substitution-with-ripgrep/#other-alternatives-for-sed>Other alternatives for sed</a></ul></nav></div></div><article class=post><header class=post__header><h1 class=post__title><a href=https://learnbyexample.github.io/substitution-with-ripgrep/>Search and replace tricks with ripgrep</a></h1><div class=post__meta><span class=post__time>2020-09-16</span></div></header><div class=post-content><p><a href=https://github.com/BurntSushi/ripgrep>ripgrep</a> (command name <code>rg</code>) is a <code>grep</code> tool, but supports search and replace as well. <code>rg</code> is far from a like-for-like alternate for <code>sed</code>, but it has nifty features like multiline replacement, fixed string matching, <code>PCRE2</code> support, etc. This post gives an overview of syntax for substitution and highlights some of the cases where <code>rg</code> is a handy replacement for <code>sed</code>.</p><span id=continue-reading></span><br><h2 id=global-search-and-replace>Global search and replace<a aria-label="Anchor link for: global-search-and-replace" class=zola-anchor href=#global-search-and-replace>ğŸ”—</a></h2><pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ cat ip.txt
</span><span>dark blue, light blue
</span><span>light orange
</span><span>blue sky
</span><span>
</span><span style=color:#7f8989;># by default, line number is displayed if output destination is stdout
</span><span style=color:#7f8989;># by default, only lines that matched the given pattern is displayed
</span><span style=color:#7f8989;># 'blue' is search pattern and -r 'red' is replacement string
</span><span>$ rg </span><span style=color:#d07711;>'blue' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'red'</span><span> ip.txt
</span><span style=color:#b3933a;>1:dark</span><span> red, light red
</span><span style=color:#b3933a;>3:red</span><span> sky
</span><span>
</span><span style=color:#7f8989;># --passthru option is useful to print all lines, whether or not it matched
</span><span style=color:#7f8989;># -N will disable line number prefix
</span><span style=color:#7f8989;># this command is similar to: sed 's/blue/red/g' ip.txt
</span><span>$ rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>N </span><span style=color:#d07711;>'blue' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'red'</span><span> ip.txt
</span><span>dark red, light red
</span><span>light orange
</span><span>red sky
</span></code></pre><br><h2 id=matching-nth-occurrence>Matching Nth occurrence<a aria-label="Anchor link for: matching-nth-occurrence" class=zola-anchor href=#matching-nth-occurrence>ğŸ”—</a></h2><p>As seen in previous example, <code>rg</code> will search and replace all occurrences. So, you'll have to be creative with regexp to replace only a specific occurrence per input line.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'see bat hot at but at go gate at sat at but at'
</span><span>
</span><span style=color:#7f8989;># replace first occurrence only
</span><span style=color:#7f8989;># same as: sed 's/\bat\b/[xyz]/'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>N </span><span style=color:#d07711;>'\bat\b(.*)' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'[xyz]$1'
</span><span>see bat hot [xyz] but at go gate at sat at but at
</span><span>
</span><span style=color:#7f8989;># same as: sed 's/\bat\b/[xyz]/3'
</span><span style=color:#7f8989;># the number within {} is N-1 to replace Nth occurrence, for N>1
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>N </span><span style=color:#d07711;>'^((.*?\bat\b){2}.*?)\bat\b' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'$1[xyz]'
</span><span>see bat hot at but at go gate [xyz] sat at but at
</span><span>
</span><span style=color:#7f8989;># replace last but Nth occurrence, for N>=0
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>N </span><span style=color:#d07711;>'^(.*)\bat\b((.*\bat\b){3})' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'$1[xyz]$2'
</span><span>see bat hot at but [xyz] go gate at sat at but at
</span></code></pre><br><h2 id=in-place-workaround>In-place workaround<a aria-label="Anchor link for: in-place-workaround" class=zola-anchor href=#in-place-workaround>ğŸ”—</a></h2><p><code>rg</code> doesn't support in-place option, so you'll have to do it yourself.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># -N isn't needed here as output destination is a file
</span><span style=color:#7f8989;># same as: sed -i 's/blue/red/g' ip.txt
</span><span>$ rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'blue' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'red'</span><span> ip.txt </span><span style=color:#72ab00;>></span><span> tmp.txt </span><span style=color:#72ab00;>&&</span><span> mv tmp.txt ip.txt
</span><span>
</span><span>$ cat ip.txt
</span><span>dark red, light red
</span><span>light orange
</span><span>red sky
</span></code></pre><p>If you have <a href=https://joeyh.name/code/moreutils/>moreutils installed</a>, then you could use <code>sponge</code> as well.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'blue' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'red'</span><span> ip.txt </span><span style=color:#72ab00;>|</span><span> sponge ip.txt
</span></code></pre><br><h2 id=rust-regex-and-pcre2>Rust regex and PCRE2<a aria-label="Anchor link for: rust-regex-and-pcre2" class=zola-anchor href=#rust-regex-and-pcre2>ğŸ”—</a></h2><p>By default, <code>rg</code> uses Rust regular expressions, which is much more featured compared to <code>GNU sed</code>. The main feature not supported is backreference within regexp definition (for performance reasons). See <a href=https://docs.rs/regex/1.3.9/regex/index.html>Rust regex documentation</a> for regular expression syntax and features. <code>rg</code> supports Unicode by default.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># non-greedy quantifier is supported
</span><span>$ s=</span><span style=color:#d07711;>'food land bark sand band cue combat'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'foo.*?ba' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'[xyz]'
</span><span>[xyz]rk sand band cue combat
</span><span>
</span><span style=color:#7f8989;># unicode support
</span><span>$ echo </span><span style=color:#d07711;>'fox:Î±Î»ÎµÏ€Î¿Ï,eagle:Î±ÎµÏ„ÏŒÏ‚' </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'\p{L}+' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'($0)'
</span><span>(fox)</span><span style=color:#72ab00;>:</span><span>(Î±Î»ÎµÏ€Î¿Ï),(eagle)</span><span style=color:#72ab00;>:</span><span>(Î±ÎµÏ„ÏŒÏ‚)
</span><span>
</span><span style=color:#7f8989;># set operator example, remove all punctuation characters except . ! and ?
</span><span>$ para=</span><span style=color:#d07711;>'"hi", there! how *are* you? all fine here.'
</span><span>$ echo </span><span style=color:#d07711;>"$para" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'[[:punct:]--[.!?]]+' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>''
</span><span>hi there! how are you? all fine here.
</span></code></pre><p>The <code>-P</code> switch will enable <a href=https://www.pcre.org/current/doc/html/index.html>PCRE2</a> flavor, which has even more tricks. You can also use <code>--engine=auto</code> to allow <code>rg</code> to automatically use <code>PCRE2</code> when needed (for example: useful as an alias for <code>rg</code> command so that it gives performance of Rust engine by default and use <code>PCRE2</code> only when needed).<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># backreference within regexp definition
</span><span>$ s=</span><span style=color:#d07711;>'cocoa appleseed tool speechless'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span>wP </span><span style=color:#d07711;>'([a-z]*([a-z])\2[a-z]*){2}' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'{$0}'
</span><span>cocoa {appleseed} tool {speechless}
</span><span>
</span><span style=color:#7f8989;># replace all whole words except 'imp' and 'ant'
</span><span>$ s=</span><span style=color:#d07711;>'tiger imp goat eagle ant important'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>P </span><span style=color:#d07711;>'\b(imp|ant)\b(*SKIP)(*F)|\w+' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'[$0]'
</span><span>[tiger] imp [goat] [eagle] ant [important]
</span><span>
</span><span style=color:#7f8989;># recursively match parentheses
</span><span>$ eqn=</span><span style=color:#d07711;>'(3+a)x * y((r-2)*(t+2)/6) + z(a(b(c(d(e)))))'
</span><span>$ echo </span><span style=color:#d07711;>"$eqn" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>P </span><span style=color:#d07711;>'\((?:[^()]++|(?0))++\)' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>''
</span><span>x </span><span style=color:#72ab00;>*</span><span> y </span><span style=color:#72ab00;>+</span><span> z
</span><span>
</span><span>$ </span><span style=color:#7f8989;># all lowercase letters and optional hyphen combo from start of string
</span><span>$ s=</span><span style=color:#d07711;>'apple-fig-mango guava grape'
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>P </span><span style=color:#d07711;>'\G([a-z]+)(-)?' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'($1)$2'
</span><span>(apple)</span><span style=color:#72ab00;>-</span><span>(fig)</span><span style=color:#72ab00;>-</span><span>(mango) guava grape
</span></code></pre><br><h2 id=extract-and-modify>Extract and modify<a aria-label="Anchor link for: extract-and-modify" class=zola-anchor href=#extract-and-modify>ğŸ”—</a></h2><p>The <code>-r</code> option can be used when <code>-o</code> option is active too. The example shown below is not easy to do with <code>sed</code>.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'0501 035 154 12 26 98234'
</span><span>
</span><span style=color:#7f8989;># numbers >= 100 and ignore leading zeros
</span><span>$ echo </span><span style=color:#d07711;>"$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>-</span><span>woP </span><span style=color:#d07711;>'0*+(\d{3,})' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'"$1"' </span><span style=color:#72ab00;>|</span><span> paste </span><span style=color:#72ab00;>-</span><span>sd,
</span><span style=color:#d07711;>"501"</span><span>,</span><span style=color:#d07711;>"154"</span><span>,</span><span style=color:#d07711;>"98234"
</span></code></pre><br><h2 id=fixed-string-matching>Fixed string matching<a aria-label="Anchor link for: fixed-string-matching" class=zola-anchor href=#fixed-string-matching>ğŸ”—</a></h2><p>Like <code>grep</code>, the <code>-F</code> option will allow fixed strings to be matched, a handy option that I feel every search and replace tool should provide.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ </span><span style=color:#b39f04;>printf </span><span style=color:#d07711;>'2.3/[4]*6\nfoo\n5.3-[4]*9\n' </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>F </span><span style=color:#d07711;>'[4]*' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'2'
</span><span style=color:#b3933a;>2.3</span><span style=color:#72ab00;>/</span><span style=color:#b3933a;>26
</span><span>foo
</span><span style=color:#b3933a;>5.3</span><span style=color:#72ab00;>-</span><span style=color:#b3933a;>29
</span></code></pre><p><code>-F</code> doesn't extend to replacement section though, so you need <code>$$</code> instead of <code>$</code> character to represent it literally.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ echo </span><span style=color:#d07711;>'a.*{2}-b' </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>F </span><span style=color:#d07711;>'.*{2}' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'+$x\tc'
</span><span>a</span><span style=color:#72ab00;>+</span><span>\tc</span><span style=color:#72ab00;>-</span><span>b
</span><span>$ echo </span><span style=color:#d07711;>'a.*{2}-b' </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>F </span><span style=color:#d07711;>'.*{2}' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'+$$x\tc'
</span><span>a</span><span style=color:#72ab00;>+</span><span style=color:#5597d6;>$x</span><span>\tc</span><span style=color:#72ab00;>-</span><span>b
</span></code></pre><br><h2 id=multiline-matching>Multiline matching<a aria-label="Anchor link for: multiline-matching" class=zola-anchor href=#multiline-matching>ğŸ”—</a></h2><p>Another handy option is <code>-U</code> which enables multiline matching.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span>$ s=</span><span style=color:#d07711;>'hi there\nhave a nice day\nbye'
</span><span>
</span><span style=color:#7f8989;># (?s) flag will allow . to match newline characters as well
</span><span>$ </span><span style=color:#b39f04;>printf </span><span style=color:#d07711;>'</span><span style=color:#aeb52b;>%b</span><span style=color:#d07711;>' "$s" </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>U </span><span style=color:#d07711;>'(?s)the.*ice' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>''
</span><span>hi  day
</span><span>bye
</span></code></pre><p><img alt=info src=/images/info.svg> See <a href=https://learnbyexample.github.io/multiline-search-and-replace/>my blog post</a> for a detailed discussion on multiline fixed string search and replace operations from the command line.</p><br><h2 id=handling-dos-style-input>Handling dos-style input<a aria-label="Anchor link for: handling-dos-style-input" class=zola-anchor href=#handling-dos-style-input>ğŸ”—</a></h2><p><code>rg</code> provides support for dos-style files with <code>--crlf</code> option.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># same as: sed -E 's/\w+(\r?)$/xyz\1/'
</span><span style=color:#7f8989;># note that output will retain CR+LF as line ending
</span><span style=color:#7f8989;># similar to the sed solution, this will work for unix-style input too
</span><span>$ </span><span style=color:#b39f04;>printf </span><span style=color:#d07711;>'hi there\r\ngood day\r\n' </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>--</span><span>crlf </span><span style=color:#d07711;>'\w+$' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'xyz'
</span><span>hi xyz
</span><span>good xyz
</span></code></pre><br><h2 id=speed-comparison-with-gnu-sed>Speed comparison with GNU sed<a aria-label="Anchor link for: speed-comparison-with-gnu-sed" class=zola-anchor href=#speed-comparison-with-gnu-sed>ğŸ”—</a></h2><p>Another advantage of <code>rg</code> is that it is likely to be faster than <code>sed</code>. See <a href=https://blog.burntsushi.net/ripgrep/>ripgrep benchmark with other grep implementations</a> by the author for a methodological detailed analysis and insights.<pre class=language-ruby data-lang=ruby style=background-color:#f5f5f5;color:#1f1f1f;><code class=language-ruby data-lang=ruby><span style=color:#7f8989;># for small files, initial processing time of rg is a large component
</span><span>$ time echo </span><span style=color:#d07711;>'aba' </span><span style=color:#72ab00;>|</span><span> sed </span><span style=color:#d07711;>'s/a/b/g' </span><span style=color:#72ab00;>></span><span> f1
</span><span>real	0m0.002s
</span><span>$ time echo </span><span style=color:#d07711;>'aba' </span><span style=color:#72ab00;>|</span><span> rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'a' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'b' </span><span style=color:#72ab00;>></span><span> f2
</span><span>real	0m0.007s
</span><span>
</span><span style=color:#7f8989;># for larger files, rg is likely to be faster
</span><span style=color:#7f8989;># 6.2M sample ASCII file
</span><span>$ wget </span><span style=color:#d07711;>'https://norvig.com/big.txt'
</span><span>$ time </span><span style=color:#c23f31;>LC_ALL</span><span style=color:#72ab00;>=</span><span style=color:#5597d6;>C</span><span> sed </span><span style=color:#d07711;>'s/\bcat\b/dog/g'</span><span> big.txt </span><span style=color:#72ab00;>></span><span> f1
</span><span>real	0m0.060s
</span><span>$ time rg </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#d07711;>'\bcat\b' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'dog'</span><span> big.txt </span><span style=color:#72ab00;>></span><span> f2
</span><span>real	0m0.048s
</span><span>$ diff </span><span style=color:#72ab00;>-</span><span>s f1 f2
</span><span style=color:#5597d6;>Files</span><span> f1 </span><span style=color:#72ab00;>and</span><span> f2 are identical
</span><span>
</span><span style=color:#7f8989;># nearly 8 times faster!!
</span><span>$ time </span><span style=color:#c23f31;>LC_ALL</span><span style=color:#72ab00;>=</span><span style=color:#5597d6;>C</span><span> sed </span><span style=color:#72ab00;>-</span><span style=color:#5597d6;>E </span><span style=color:#d07711;>'s/\b(\w+)(\s+\1)+\b/\1/g'</span><span> big.txt </span><span style=color:#72ab00;>></span><span> f1
</span><span>real	0m0.725s
</span><span>$ time rg </span><span style=color:#72ab00;>--</span><span>no</span><span style=color:#72ab00;>-</span><span>unicode </span><span style=color:#72ab00;>--</span><span>passthru </span><span style=color:#72ab00;>-</span><span>wP </span><span style=color:#d07711;>'(\w+)(\s+\1)+' </span><span style=color:#72ab00;>-</span><span>r </span><span style=color:#d07711;>'$1'</span><span> big.txt </span><span style=color:#72ab00;>></span><span> f2
</span><span>real	0m0.093s
</span><span>$ diff </span><span style=color:#72ab00;>-</span><span>s f1 f2
</span><span style=color:#5597d6;>Files</span><span> f1 </span><span style=color:#72ab00;>and</span><span> f2 are identical
</span></code></pre><br><h2 id=other-alternatives-for-sed>Other alternatives for sed<a aria-label="Anchor link for: other-alternatives-for-sed" class=zola-anchor href=#other-alternatives-for-sed>ğŸ”—</a></h2><ul><li><a href=https://unix.stackexchange.com/questions/112023/how-can-i-replace-a-string-in-a-files/251742#251742>rpl</a> â€” search and replace tool, has interesting options like interactive mode and recursive mode<li><a href=https://github.com/chmln/sd>sd</a> â€” simple search and replace, implemented in Rust<li><a href=https://www.perl.org/>perl</a> and <a href=https://www.ruby-lang.org/en/>ruby</a> â€” programming languages with excellent command line support</ul></div><div class=post-footer><div class=post-tags><a href=https://learnbyexample.github.io/tags/ripgrep/>#ripgrep</a><a href=https://learnbyexample.github.io/tags/substitution/>#substitution</a><a href=https://learnbyexample.github.io/tags/fixed-string/>#fixed-string</a><a href=https://learnbyexample.github.io/tags/multiline/>#multiline</a><a href=https://learnbyexample.github.io/tags/regular-expressions/>#regular-expressions</a></div><hr color=#e6e6e6><div class=post-nav><p><a class=previous href=https://learnbyexample.github.io/sed-lookarounds/>â† Emulating regexp lookarounds in GNU sed</a><br><p><a class=next href=https://learnbyexample.github.io/python-intermediate/>I know Python basics, what next? â†’</a><br></div><hr color=#e6e6e6><p>ğŸ“° Use <a href=https://learnbyexample.github.io/atom.xml>this link</a> for the Atom feed. <br> âœ… Follow me on <a href=https://twitter.com/learn_byexample>Twitter</a>, <a href=https://github.com/learnbyexample>GitHub</a> and <a href=https://www.youtube.com/c/learnbyexample42>Youtube</a> for interesting tech nuggets. <br> ğŸ“§ Subscribe to <a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>learnbyexample weekly</a> for programming resources, tips, tools, free ebooks and more (free newsletter, delivered every Friday).<hr color=#e6e6e6></div></article></div></main></div><script src=https://learnbyexample.github.io/even.js></script>